@top Program { Item* }

@precedence { op @left, as @right }

@skip { space | LineComment }

commaSep<content> {
  (content ("," content)* ","?)?
}

semiSep<content> {
  (content (";" content)* ";"?)?
}

Item {
  Type_Decl |
  Relation_Decl |
  Const_Decl |
  Query_Decl
}

Type_Decl {
  Keyword<"type"> Identifier "=" Type |
  Keyword<"type"> Identifier "<:" Type |
  Keyword<"type"> Identifier Param_List<Type> |
  Keyword<"type"> Identifier Param_List<Var> |
  Keyword<"type"> "$" Identifier Param_List<Var> ("->" Type)?
}

Var { Identifier (":" Type)? }

Relation_Decl {
  Fact_Decl | Facts_Set_Decl | Rule_Decl
}

Fact_Decl {
  Keyword<"rel"> Identifier Param_List<Const_Expr> |
  Keyword<"rel"> Tagged<Identifier Param_List<Const_Expr>>
}

Facts_Set_Decl { Keyword<"rel"> Identifier "=" Facts_Set }

Facts_Set {
  "{" (
    commaSep<Const_Tuple> ~ambigFacts |
    commaSep<Tagged<Const_Tuple>> ~ambigFacts |
    semiSep<Tagged<Const_Tuple>> ~ambigFacts
  ) "}"
}

Const_Decl {
  Keyword<"const"> Var "=" Constant
}

Constant {
  Boolean | Number | String | Identifier
}

Const_Tuple {
  Constant | "(" commaSep<Constant> ")"
}

Const_Expr[@dynamicPrecedence=1] {
  Constant ~constant |
  Const_Expr !op bin_op Const_Expr | unary_op Const_Expr |
  "$" Identifier Param_List<Const_Expr> |
  Keyword<"if"> Const_Expr Keyword<"then"> Const_Expr Keyword<"else"> Const_Expr |
  "(" Const_Expr ")"
}

Expr {
  Constant ~constant |
  Expr !op bin_op Expr | unary_op Expr |
  "$" Identifier Param_List<Expr> |
  Keyword<"if"> Expr Keyword<"then"> Expr Keyword<"else"> Expr |
  Expr !as Keyword<"as"> Type |
  "(" Expr ")"
}

Atom {
  Identifier Param_List<Expr>
}

Param_List<expr> { "(" commaSep<expr> ~ambigParams ")" }

Formula {
  Atom | "~" Atom | WordOp<"not"> Atom |
  Formula !op formula_op Formula |
  "(" Formula ")"
}

Rule_Decl {
  Keyword<"rel"> Atom ":-" Formula | Keyword<"rel"> Atom "=" Formula |
  Keyword<"rel"> Tagged<Atom> ":-" Formula | Keyword<"rel"> Tagged<Atom> "=" Formula
}

Query_Decl {
  Keyword<"query"> Identifier | Keyword<"query"> Atom
}

Tag {
  Boolean | Number
}

Tagged<expr> {
  Tag "::" expr
}

Boolean { @specialize<Identifier, "true" | "false"> }

unary_op { ArithOp<"-"> | LogicOp<"!"> | WordOp<"not"> }

bin_op {
  ArithOp<"+"> | ArithOp<"-"> | ArithOp<"*"> | ArithOp<"/"> | ArithOp<"%"> | ArithOp<"^"> |
  LogicOp<"&&"> | LogicOp<"||"> | WordOp<"and"> | WordOp<"or"> | WordOp<"implies"> | CompareOp
}

formula_op {
  LogicOp<","> | LogicOp<"/\\"> | LogicOp<"\\/"> | LogicOp<"=>"> |
  WordOp<"and"> | WordOp<"or"> | WordOp<"implies">
}

WordOp<term> { @specialize<Identifier, term> }

Type { @specialize<Identifier, 
  "u8" | "u16" | "u32" | "u64" | "u128" | "usize" |
  "i8" | "i16" | "i32" | "i64" | "i128" | "isize" |
  "f32" | "f64" | "char" | "bool" | "String"> }

Keyword<term> { @specialize[@name={term}]<Identifier, term> }

@tokens {
  Identifier { $[a-zA-Z_0-9]+ }

  Number { (@digit ("_" | @digit)* ("." ("_" | @digit)*)? | "." @digit ("_" | @digit)*) }

  String { '"' (!["\\] | "\\" _)* '"' }

  LineComment { "//" ![\n]* }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  CompareOp { ("<" | ">" | "==" | "!=") "="? }

  space { @whitespace+ }

  @precedence {
    LineComment,
    String, Number,
    LogicOp, ArithOp, CompareOp,
    Identifier
  }
}

@detectDelim
