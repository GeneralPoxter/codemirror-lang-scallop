@top Program { Item* }

@precedence { op @left }

@skip { space | LineComment }

commaSep<content> {
  (content ("," content)* ","?)?
}

commaSep1<content> {
  content ("," content)* ","?
}

semiSep<content> {
  (content (";" content)* ";"?)?
}

Boolean { @specialize<Identifier, "true" | "false"> }

unaryOp { ArithOp<"-"> | LogicOp<"!"> }

binOp {
  ArithOp<"+" | "-" | "*" | "/"| "%" | "^"> |
  LogicOp<"&&" | "||"> | WordOp<"and" | "or" | "implies"> | CompareOp
}

formulaOp {
  LogicOp<"," | "/\\" | "\\/" | "=>"> |
  WordOp<"and" | "or" | "implies">
}

WordOp<term> { @specialize<Identifier, term> }

Keyword<term> { @specialize[@name={term}]<Identifier, term> }

Item {
  TypeDecl |
  RelationDecl |
  ConstDecl |
  QueryDecl |
  FADecl
}

Type { @specialize<Identifier, 
  "u8" | "u16" | "u32" | "u64" | "u128" | "usize" |
  "i8" | "i16" | "i32" | "i64" | "i128" | "isize" |
  "f32" | "f64" | "char" | "bool" | "String" |
  "DateTime" | "Duration" | "Tensor"> }

Adornment { @specialize<Identifier, "bound" | "free" >}

Var { Identifier (":" Type)? }

ParamList<expr> { "(" commaSep<expr> ~ambigParams ")" }

TypeDecl {
  Keyword<"type"> Identifier AssignOp<"<:"> Type |
  Keyword<"type"> commaSep1<Identifier ParamList<Type>> |
  Keyword<"type"> commaSep1<Identifier ParamList<Var | Adornment Var>> |
  Keyword<"type"> FFIdentifier ParamList<Var> ("->" Type)?
}

RelationDecl {
  FactDecl | FactSetDecl | RuleDecl
}

Tag {
  Boolean | Number
}

Tagged<expr> {
  Tag "::" expr
}

FactDecl {
  Keyword<"rel"> Identifier ParamList<ConstExpr> |
  Keyword<"rel"> Tagged<Identifier ParamList<ConstExpr>>
}

FactSetDecl {
  Keyword<"rel"> Identifier AssignOp<":="> FactSet
}

FactSet {
  "{" (
    commaSep<ConstTuple> ~ambigFacts |
    commaSep<Tagged<ConstTuple>> ~ambigFacts |
    semiSep<Tagged<ConstTuple>> ~ambigFacts
  ) "}"
}

ConstDecl {
  Keyword<"const"> Var AssignOp<":="> Constant
}

Constant {
  Boolean | Number | String
}

ConstTuple {
  Constant | "(" commaSep<Constant> ")"
}

ConstExpr[@dynamicPrecedence=1] {
  Constant ~constant |
  ConstExpr !op binOp ConstExpr | unaryOp ConstExpr |
  FFIdentifier ParamList<ConstExpr> |
  Keyword<"if"> ConstExpr Keyword<"then"> ConstExpr Keyword<"else"> ConstExpr |
  "(" ConstExpr ")"
}

Expr {
  Identifier |
  Constant ~constant |
  Expr !op binOp Expr | unaryOp Expr |
  FFIdentifier ParamList<Expr> |
  Keyword<"if"> Expr Keyword<"then"> Expr Keyword<"else"> Expr |
  Expr !op Keyword<"as"> Type |
  "(" Expr ~ambigExpr  ")"
}

Atom {
  Identifier ParamList<Expr>
}

Formula {
  Atom | "~" Atom | WordOp<"not"> Atom |
  Formula !op formulaOp Formula |
  Constraint | Aggregation |
  "(" Formula ")"
}

Constraint {
  Expr ~ambigExpr
}

RuleDecl {
  Keyword<"rel"> Atom AssignOp<":-" | ":="> Formula |
  Keyword<"rel"> Tagged<Atom> AssignOp<":-" | ":=">  Formula
}

Aggregator { @extend<Identifier,
  "count" | "count!" | "top" | 
  "sum" | "prod" | "min" | "max" |
  "exists" | "forall" | "unique"> }

BoolAggregator { @extend<Identifier, "forall" | "unique"> }

GroupVars { commaSep1<Identifier> }

AggregationArgs {
  "[" commaSep1<Identifier> "]" | "<" commaSep1<Constant> ">"
}

Aggregation {
  Identifier AssignOp<":="> Aggregator AggregationArgs? "(" GroupVars ":" Formula
    (Keyword<"where"> GroupVars ":" Formula)? ")" |
  BoolAggregator "(" GroupVars ":" Formula ")"
}

QueryDecl {
  Keyword<"query"> Identifier | Keyword<"query"> Atom
}

FAParamVal {
  Boolean | Number | String |
  "[" commaSep<FAParamVal> "]" |
  "(" commaSep<FAParamVal> ")"
}

FAParam {
  (Identifier AssignOp<"=">)? FAParamVal
}

FADecl {
  FAIdentifier ParamList<FAParam>
}

@tokens {
  FFIdentifier { "$" Identifier }
  FAIdentifier { "@" Identifier }
  Identifier { $[a-zA-Z_] $[a-zA-Z_0-9]* }

  Number { (@digit ("_" | @digit)* ("." ("_" | @digit)*)? | "." @digit ("_" | @digit)*) }

  String { '"' (!["\\] | "\\" _)* '"' }

  LineComment { "//" ![\n]* }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  AssignOp<expr> { expr | "=" }
  CompareOp { ("<" | ">") "="? | "==" | "!=" }

  space { @whitespace+ }

  @precedence {
    LineComment, String, Number, ArithOp
  }
}

@detectDelim
